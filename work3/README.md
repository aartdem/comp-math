# Структура файла для промежуточного представления
В файле хранится разложениие $A=U\Sigma V^T$ для каждого из трех каналов изображения. Структура файла:
Смещение от начала (hex)|Размер (в байтах)|Описание|
--|--|--
00|4|Сигнатура формата, всегда содержит $43\ 42\ 4D\ 50\ _{16}$ (Строка "CBMP", если каждый символ представить в ASCII)
04|4|Число n - высота картинки (int32)
08|4|Число m - ширина картинки (int32)
0C|4|Число k - количество вычисленных сингулярных чисел (int32)
10|$3 * 4 * k * (n + m + 1)$ | Данные о трех цветовых каналов, между данными из каналов нет разделителей. Для каждого канала хранится матрица U, k сингулярных чисел и матрица $V^T$. Все числа хранятся в формате float32.

k считается по формуле $k = \dfrac {n*m} {4 * ratio * (n + m + 1))}$, где $ratio$ - отношение размера исходного фалйа к сжатому (требуемый настраиваемый параметр).
# Сравнение работы алгоритмов
## Реализованные алгоритмы
* Библиотечный алгоритм - алгоритм SVD из библиотеки numpy.
* Самописный примитивный алгоритм - степенной метод, вычисляющий сингулярные числа по очереди в порядке уменьшения их значений.
* Улучшенный самописный алгоритм - Block SVD Power Method, [раздел 4 из статьи](https://sciendo.com/article/10.1515/auom-2015-0024?content-tab=abstract).

Рассмотрим картинку nature.bmp 1472×2208 пикселей. Будем сжимать ее в 2 раза. Под временем работы будем понимать только алгоритм сжатия, без восстановления. 
Библиотечный алгоритм из numpy считает SVD в среднем 
за 3.47 секунд (было сделано 20 запусков). Самописные алгоритмы можно ограничивать двумя параметрами - временем работы и толерантностью. 
Возьмем толерантность(eps) = 1e-8. Для Block SVD Power получилось поставить ограничение 1000ms на канал, что позволило достичь неотличимого на глаз качества за меньшее время (3 секунды):

|Numpy|Block power|
|-----|-----------|
![](nature_results/nature_numpy.bmp)|![](nature_results/nature_block_power.bmp)

С обычным степенным методом ситуация оказалась хуже, так как в коде присутствует тяжелая операция перемножения матрицы 
изображения на транспонированную к ней (для обработки прямоугольной матрицы). Из-за этого 
не получилось добиться сравнимых с прошлыми алгоритмами результатов за такое же время.
Результаты для обычного степенного метода:

| 45 сек                               | 90 сек                                     |150 сек
|--------------------------------------|--------------------------------------------|--------
 ![](nature_results/nature_power_simple-45sec.bmp) | ![](nature_results/nature_power_simple-90sec.bmp) |![](nature_results/nature_power_simple-150sec.bmp)

С увеличением отведенного на алгоритм времени мы видим увеличение качества. Это логично, так как при увеличении времени работы мы считаем больше сингулярных чисел, что повышает точность.