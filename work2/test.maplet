
`Построение`*`кубического`*`сплайна`;
restart;
n := 10;
grid := Array(1 .. n + 1, i -> (i - 1)/n);
gamma_1 := 0;
gamma_(n + 1) := 0;
h := Array(1 .. n, i -> grid[i + 1] - grid[i]);
y := Array(1 .. n + 1, i -> f(grid[i]));
initMatrix := proc(i, j) if i = 1 and j = 1 then return 1; elif i = n + 1 and j = n + 1 then return 1; elif i = j then return 2*h[i - 1] + 2*h[i]; elif abs(i - j) = 1 and i <> 1 and i <> n + 1 then return h[min(i, j)]; else return 0; end if; end proc;
initVector := proc(i) if i = 1 then return gamma_1; elif i = n + 1 then return gamma_(n + 1); else return 6*(y[i + 1] - y[i])/h[i] - 6*(y[i] - y[i - 1])/h[i]; end if; end proc;
with(LinearAlgebra);
A := Matrix(n + 1, n + 1, initMatrix);
b := Vector(n + 1, initVector);
gamma_sol := LinearSolve(A, b);
K1 := Array(1 .. n, i -> y[i]/h[i] - 1/6*gamma_sol[i]*h[i]);
K2 := Array(1 .. n, i -> y[i + 1]/h[i] - 1/6*gamma_sol[i + 1]*h[i]);
S := Array(1 .. n, i -> x -> 1/6*gamma_sol[i]*(grid[i + 1] - x)^3/h[i] + 1/6*gamma_sol[i + 1]*(x - grid[i])^3/h[i] + K1[i]*(grid[i + 1] - x) + K2[i]*(x - grid[i]));
cubicSplineInterp := proc(x) local i; for i to n do if grid[i] <= x and x <= grid[i + 1] then return S[i](x); end if; end do; end proc;

NULL;
NULL;
B*`Построение`*`интерполяции` - `сплайнами`;
n := 10;
grid := Array(1 .. n + 1, i -> (i - 1)/n);
EPS := 10^(-12);
getX := proc(i) if n + 1 < i then return grid[n + 1] + (i - n)*EPS; elif i < 1 then return grid[1] + (1 - i)*EPS; else return grid[i]; end if; end proc;
getC := proc(j) local x_0, x_1, x_2; x_0 := getX(j + 1); x_1 := (getX(j + 1) + getX(j + 2))/2; x_2 := getX(j + 2); return -1/2*f(x_0) + 2*f(x_1) - 1/2*f(x_2); end proc;
B := proc(j, d, x) if d = 0 then return piecewise(getX(j) <= x and x < getX(j + 1), 1, 0)(x); else return (x - getX(j))*B(j, d - 1, x)/(getX(j + d) - getX(j)) + (getX(j + 1 + d) - x)*B(j + 1, d - 1, x)/(getX(j + 1 + d) - getX(j + 1)); end if; end proc;
BSplineApprox := proc(x) local i, k; for i to n do if getX(i) <= x and x <= getX(i + 1) then return add(B(k, 2, x)*getC(k), k = i - 2 .. i); end if; end do; end proc;
NULL;
`Функции`*`для`*`подсчета`*`ошибки`;
calculateError := proc(actual, expected) local check_grid, max_error, i; check_grid := Array(1 .. 10*n + 1, i -> 1/10*(i - 1)/n); max_error := 0; for i to 10*n + 1 do max_error := max(max_error, abs(actual(check_grid(i)) - expected(check_grid(i)))); end do; return max_error; end proc;
# Пример (0)
# Сравним получившуюся интерполяцию кубическими сплайными с готовым решением Maple:
f := x -> sqrt(x);
yVals := Array(1 .. n + 1, i -> f(grid[i]));
with(Student[NumericalAnalysis]);
points := [seq([grid[i], yVals[i]], i = 1 .. n + 1)];
mapleCubicInterp := MakeFunction(expand(Interpolant(CubicSpline(points, independentvar = x))), x);
print(`Ошибка`*`получившейся`*`интерполяции`);
err_01 := calculateError(cubicSplineInterp, f);
evalf(err_01, 2);
print(`Ошибка`*`решения`*Maple);
err_02 := calculateError(mapleCubicInterp, f);
evalf(err_02, 2);
# Получили примерно одинаковые значения, что свидетельствует о правильности написанного алгоритма.

Пример(1);
`В`*книге*"С. П. Шарого "*Курс*`вычислительных`*`методов"`*в*`разделе`*про*`сплайны`*`была`*`упомянута`*`функция`*`Рунге`, Typesetting[delayDotProduct]((`для`*`которой`*при*`интерполяции`*`полиномами`*`наблюдается`*`эффект`*`осциляций`) . А, `также`, true)*`было`*`отметечено`, (`что`*"последовательность интерполяционных кубических сплайнов на равномерной сетке узлов всегда сходится к интерполируемой непрерывной функции") . `Значит`, Typesetting[delayDotProduct]((Typesetting[delayDotProduct]((`что`*`ошибка`*при*`интерполяции`*`кубическими`*`сплайнами`*`для`*`этой`*`функции`*`будет`*`меньше`) . `Давайте`, `это`, true)*проверим) . `Так`, `как`, true)*`мы`*`работаем`*`на`*`отрезке`*[0, 1], немного*`видоизменим`*`функцию`;
f := x -> 1/(1 + 25*(0.5 - x)^2);
yVals := Array(1 .. n + 1, i -> f(grid[i]));
`Найдём`*`максимальную`*`ошибку`*при*`интерполяции`*`кубическими`*`сплайнами`;
err_1 := calculateError(cubicSplineInterp, f);
evalf(err_1, 1);
# Для получения интерполяции полиномами будем использовать стандартные средства Maple. Найдем максимальную ошибку:
with(CurveFitting);
polyInterpolation := x -> PolynomialInterpolation(grid, yVals, x);
err_2 := calculateError(polyInterpolation, f);
evalf(err_2, 2);
# Мы видим, что ошибка отличается больше чем в 82 раза. Пронаблюдаем теперь это на графике:
plot([f, cubicSplineInterp, polyInterpolation], 0 .. 1, color = ["Red", "Green", "Blue"], legend = ["Original f", "Cubic Spline", "Poly interpolation"]);
# Таким образом, мы показали, что интерполяция кубическими сплайнами благодаря своим свойствам позволила избежать эффекта осциляций на концах отрезка.
NULL;


